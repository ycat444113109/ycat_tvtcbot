
**Ù„Ù„Ø§Ø³ØªÙØ³Ø§Ø±Ø§Øª ÙˆØ§Ù„Ø¯Ø¹Ù…:**
Ø§Ø³ØªØ®Ø¯Ù… /help Ù„Ù„Ù…Ø³Ø§Ø¹Ø¯Ø©
        """
        self.send_message(chat_id, gitlab_info)
    
    def cmd_projects(self, chat_id, username):
        """Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹"""
        projects = self.get_user_projects(chat_id)
        if projects:
            projects_list = "\n".join([f"â€¢ {p[1]} ({p[2]})" for p in projects])
            msg = f"ğŸ“ **Ù…Ø´Ø§Ø±ÙŠØ¹Ùƒ Ø§Ù„Ù…Ø±Ø¨ÙˆØ·Ø©:**\n\n{projects_list}"
        else:
            msg = "ğŸ“­ Ù„Ø§ ØªÙˆØ¬Ø¯ Ù…Ø´Ø§Ø±ÙŠØ¹ Ù…Ø±Ø¨ÙˆØ·Ø© Ø¨Ø¹Ø¯.\n\nØ§Ø³ØªØ®Ø¯Ù… /setup Ù„Ø±Ø¨Ø· Ø£ÙˆÙ„ Ù…Ø´Ø±ÙˆØ¹."
        self.send_message(chat_id, msg)
    
    def cmd_broadcast(self, chat_id, username):
        """Ø¨Ø« Ø±Ø³Ø§Ù„Ø© Ù„Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† (Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·)"""
        # ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø¯ÙŠØ¯ Ø¢ÙŠØ¯ÙŠ Ø§Ù„Ù…Ø´Ø±ÙÙŠÙ† Ù‡Ù†Ø§
        if chat_id not in self.admin_chat_ids:
            self.send_message(chat_id, "âŒ Ù‡Ø°Ø§ Ø§Ù„Ø£Ù…Ø± Ù„Ù„Ù…Ø´Ø±ÙÙŠÙ† ÙÙ‚Ø·.")
            return
        
        # Ù‡Ù†Ø§ ÙŠÙ…ÙƒÙ† ØªØ·ÙˆÙŠØ± ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø¨Ø«
        self.send_message(chat_id, "ğŸ“¢ ÙˆØ¸ÙŠÙØ© Ø§Ù„Ø¨Ø« Ù‚ÙŠØ¯ Ø§Ù„ØªØ·ÙˆÙŠØ±...")
    
    def cmd_stats(self, chat_id, username):
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª"""
        stats = self.get_bot_stats()
        stats_msg = f"""
ğŸ“Š **Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª YCat TVTC Bot**

ğŸ‘¥ **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙˆÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙˆÙ†:** {stats['users_count']}
ğŸ“ **Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ù†Ø´Ø·Ø©:** {stats['projects_count']}
ğŸ•’ **Ø£ÙˆÙ„ ØªØ³Ø¬ÙŠÙ„:** {stats['first_user']}
ğŸ“… **Ø¢Ø®Ø± ØªØ³Ø¬ÙŠÙ„:** {stats['last_user']}

ğŸ’¾ **Ø­Ø§Ù„Ø© Ø§Ù„Ø¨ÙˆØª:** âœ… Ù†Ø´Ø·
ğŸ”§ **Ø§Ù„Ø¥ØµØ¯Ø§Ø±:** 2.0.0
        """
        self.send_message(chat_id, stats_msg)
    
    def handle_gitlab_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø­Ø¯Ø§Ø« GitLab"""
        event_type = event.get('object_kind')
        logger.info(f"ğŸ”” Processing GitLab event: {event_type}")
        
        handlers = {
            'push': self.handle_push_event,
            'issue': self.handle_issue_event,
            'merge_request': self.handle_merge_request_event,
            'pipeline': self.handle_pipeline_event,
            'tag_push': self.handle_tag_event,
            'note': self.handle_comment_event
        }
        
        if event_type in handlers:
            message = handlers[event_type](event)
            if message:
                self.broadcast_to_all_users(message)
        else:
            logger.warning(f"âš ï¸ Unhandled event type: {event_type}")
    
    def handle_push_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« push"""
        project_name = event['project']['name']
        user_name = event['user_name']
        branch = event['ref'].split('/')[-1]
        commit_count = len(event['commits'])
        commit_message = event['commits'][0]['message'] if event['commits'] else "No commits"
        
        message = f"ğŸ“¥ **Push Ø¬Ø¯ÙŠØ¯ ÙÙŠ {project_name}**\n\n" \
                 f"ğŸ‘¤ **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:** {user_name}\n" \
                 f"ğŸŒ¿ **Ø§Ù„ÙØ±Ø¹:** `{branch}`\n" \
                 f"ğŸ”¢ **Ø¹Ø¯Ø¯ Ø§Ù„Ù€ commits:** {commit_count}\n" \
                 f"ğŸ“ **Ø¢Ø®Ø± commit:** {commit_message[:100]}..."
        
        return message
    
    def handle_issue_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« issue"""
        project_name = event['project']['name']
        issue_title = event['object_attributes']['title']
        issue_state = event['object_attributes']['state']
        user_name = event['user']['name']
        action = event['object_attributes']['action']
        
        state_emoji = "âœ…" if issue_state == "closed" else "ğŸ“"
        action_text = {
            'open': 'ÙØªØ­',
            'close': 'Ø£ØºÙ„Ù‚',
            'reopen': 'Ø£Ø¹Ø§Ø¯ ÙØªØ­',
            'update': 'Ø­Ø¯Ø«'
        }.get(action, action)
        
        message = f"ğŸ¯ **Issue {action_text} ÙÙŠ {project_name}**\n\n" \
                 f"ğŸ“Œ **Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** {issue_title}\n" \
                 f"ğŸ‘¤ **Ø¨ÙˆØ§Ø³Ø·Ø©:** {user_name}\n" \
                 f"{state_emoji} **Ø§Ù„Ø­Ø§Ù„Ø©:** {issue_state}"
        
        return message
    
    def handle_merge_request_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« merge request"""
        project_name = event['project']['name']
        mr_title = event['object_attributes']['title']
        mr_state = event['object_attributes']['state']
        source_branch = event['object_attributes']['source_branch']
        target_branch = event['object_attributes']['target_branch']
        user_name = event['user']['name']
        
        message = f"ğŸ”„ **Merge Request ÙÙŠ {project_name}**\n\n" \
                 f"ğŸ“Œ **Ø§Ù„Ø¹Ù†ÙˆØ§Ù†:** {mr_title}\n" \
                 f"ğŸ‘¤ **Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…:** {user_name}\n" \
                 f"ğŸŒ¿ **Ù…Ù†:** `{source_branch}` â†’ **Ø¥Ù„Ù‰:** `{target_branch}`\n" \
                 f"ğŸ“Š **Ø§Ù„Ø­Ø§Ù„Ø©:** {mr_state}"
        
        return message
    
    def handle_pipeline_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« pipeline"""
        project_name = event['project']['name']
        pipeline_status = event['object_attributes']['status']
        ref = event['object_attributes']['ref']
        commit_message = event['commit']['message'] if event.get('commit') else "No message"
        
        status_emoji = {
            'success': 'âœ…',
            'failed': 'âŒ',
            'running': 'ğŸ”„',
            'pending': 'â³'
        }.get(pipeline_status, 'ğŸ“Š')
        
        message = f"âš™ï¸ **Pipeline {pipeline_status} ÙÙŠ {project_name}**\n\n" \
                 f"{status_emoji} **Ø§Ù„Ø­Ø§Ù„Ø©:** {pipeline_status}\n" \
                 f"ğŸŒ¿ **Ø§Ù„ÙØ±Ø¹:** `{ref}`\n" \
                 f"ğŸ“ **Ø§Ù„Ù€ commit:** {commit_message[:100]}..."
        
        return message
    
    def handle_tag_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« tag"""
        project_name = event['project']['name']
        user_name = event['user_name']
        tag_name = event['ref'].split('/')[-1]
        
        message = f"ğŸ·ï¸ **Tag Ø¬Ø¯ÙŠØ¯ ÙÙŠ {project_name}**\n\n" \
                 f"ğŸ‘¤ **Ø¨ÙˆØ§Ø³Ø·Ø©:** {user_name}\n" \
                 f"ğŸ”– **Ø§Ø³Ù… Ø§Ù„Ù€ tag:** `{tag_name}`"
        
        return message
    
    def handle_comment_event(self, event):
        """Ù…Ø¹Ø§Ù„Ø¬Ø© Ø­Ø¯Ø« ØªØ¹Ù„ÙŠÙ‚"""
        project_name = event['project']['name']
        user_name = event['user']['name']
        noteable_type = event['object_attributes']['noteable_type']
        
        message = f"ğŸ’¬ **ØªØ¹Ù„ÙŠÙ‚ Ø¬Ø¯ÙŠØ¯ ÙÙŠ {project_name}**\n\n" \
                 f"ğŸ‘¤ **Ø¨ÙˆØ§Ø³Ø·Ø©:** {user_name}\n" \
                 f"ğŸ“ **Ø¹Ù„Ù‰:** {noteable_type}"
        
        return message
    
    def register_user(self, chat_id, username, first_name):
        """ØªØ³Ø¬ÙŠÙ„ Ù…Ø³ØªØ®Ø¯Ù… Ø¬Ø¯ÙŠØ¯"""
        try:
            self.cursor.execute('''
                INSERT OR REPLACE INTO users (chat_id, username, first_name, is_active)
                VALUES (?, ?, ?, 1)
            ''', (chat_id, username, first_name))
            self.conn.commit()
            logger.info(f"âœ… User registered: {username} ({chat_id})")
        except Exception as e:
            logger.error(f"âŒ Error registering user: {e}")
    
    def get_registered_users(self):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù…Ø³Ø¬Ù„ÙŠÙ†"""
        self.cursor.execute('SELECT chat_id, username, first_name FROM users WHERE is_active = 1')
        return self.cursor.fetchall()
    
    def get_user_projects(self, chat_id):
        """Ø§Ù„Ø­ØµÙˆÙ„ Ø¹Ù„Ù‰ Ù…Ø´Ø§Ø±ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…"""
        self.cursor.execute('SELECT id, name, gitlab_url FROM projects WHERE chat_id = ?', (chat_id,))
        return self.cursor.fetchall()
    
    def get_bot_stats(self):
        """Ø¥Ø­ØµØ§Ø¦ÙŠØ§Øª Ø§Ù„Ø¨ÙˆØª"""
        # Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ†
        self.cursor.execute('SELECT COUNT(*) FROM users WHERE is_active = 1')
        users_count = self.cursor.fetchone()[0]
        
        # Ø¹Ø¯Ø¯ Ø§Ù„Ù…Ø´Ø§Ø±ÙŠØ¹
        self.cursor.execute('SELECT COUNT(*) FROM projects')
        projects_count = self.cursor.fetchone()[0]
        
        # Ø£ÙˆÙ„ ÙˆØ¢Ø®Ø± Ù…Ø³ØªØ®Ø¯Ù…
        self.cursor.execute('SELECT MIN(registered_at), MAX(registered_at) FROM users')
        first_user, last_user = self.cursor.fetchone()
        
        return {
            'users_count': users_count,
            'projects_count': projects_count,
            'first_user': first_user or 'N/A',
            'last_user': last_user or 'N/A',
            'uptime': 'Running'
        }
    
    def send_message(self, chat_id, text):
        """Ø¥Ø±Ø³Ø§Ù„ Ø±Ø³Ø§Ù„Ø© Ø¥Ù„Ù‰ Ù…Ø³ØªØ®Ø¯Ù… Ù…Ø¹ÙŠÙ†"""
        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        payload = {
            'chat_id': chat_id,
            'text': text,
            'parse_mode': 'Markdown'
        }
        
        try:
            response = requests.post(url, json=payload)
            if response.status_code == 200:
                logger.info(f"âœ… Message sent to {chat_id}")
            else:
                logger.error(f"âŒ Failed to send message: {response.text}")
        except Exception as e:
            logger.error(f"âŒ Error sending message: {e}")
    
    def broadcast_to_all_users(self, text):
        """Ø¨Ø« Ø±Ø³Ø§Ù„Ø© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ù…Ø³ØªØ®Ø¯Ù…ÙŠÙ† Ø§Ù„Ù†Ø´Ø·ÙŠÙ†"""
        users = self.get_registered_users()
        for user in users:
            chat_id = user[0]
            self.send_message(chat_id, text)
            time.sleep(0.1)  # ØªØ¬Ù†Ø¨ rate limiting
    
    def set_webhook(self, url):
        """Ø¶Ø¨Ø· webhook Ù„Ù„ØªÙ„ÙŠØ¬Ø±Ø§Ù…"""
        self.webhook_url = url
        api_url = f"https://api.telegram.org/bot{self.telegram_token}/setWebhook"
        
        try:
            response = requests.post(api_url, data={'url': f"{url}/webhook/telegram"})
            result = response.json()
            
            if result.get('ok'):
                logger.info("âœ… Telegram webhook set successfully!")
                return True
            else:
                logger.error(f"âŒ Failed to set webhook: {result}")
                return False
        except Exception as e:
            logger.error(f"âŒ Error setting webhook: {e}")
            return False
    
    def run(self, host='0.0.0.0', port=5000, debug=False):
        """ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª"""
        logger.info(f"ğŸš€ Starting YCat TVTC Bot on {host}:{port}")
        logger.info(f"ğŸ”‘ Token: {self.telegram_token[:15]}...")
        logger.info(f"ğŸ¤– Username: {self.bot_username}")
        
        if debug:
            logger.info("ğŸ”§ Debug mode is ON")
        
        self.app.run(host=host, port=port, debug=debug, use_reloader=False)

def main():
    """Ø§Ù„Ø¯Ø§Ù„Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ©"""
    bot = YCatTVTCBot()
    
    # Ø¥Ø°Ø§ ÙƒÙ†Øª ØªØ±ÙŠØ¯ Ø¶Ø¨Ø· webhook ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹ØŒ Ø£Ø¶Ù Ø§Ù„Ø±Ø§Ø¨Ø· Ù‡Ù†Ø§
    # WEBHOOK_URL = "https://your-domain.com"
    # bot.set_webhook(WEBHOOK_URL)
    
    # ØªØ´ØºÙŠÙ„ Ø§Ù„Ø¨ÙˆØª
    bot.run(debug=True)

if __name__ == '__main__':
    main()